{"version":3,"file":"fetch.js","sourceRoot":"","sources":["../src/fetch.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,EAAE,EAAE,GAAG,EAAc,MAAM,MAAM,CAAC;AAC3C,OAAO,EAAE,UAAU,EAAE,GAAG,EAAE,IAAI,EAAE,SAAS,EAAE,MAAM,gBAAgB,CAAC;AAElE,OAAO,EAAE,OAAO,EAAW,MAAM,UAAU,CAAC;AAM3C,CAAC;AAID,CAAC;AAKD,CAAC;AAEF,MAAM,OAAO,YAAY;IAGvB,YAAY,MAAmB;QAC7B,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;IACvB,CAAC;IAED,SAAS,CAAC,OAAgB;QACxB,OAAO,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,EAAE;YAC/B,MAAM,EAAE,KAAK;YACb,IAAI,EAAE,MAAM;YACZ,OAAO,EAAE,EAAE,MAAM,EAAE,WAAW,EAAE;SACjC,CAAC;aACD,IAAI,CACH,SAAS,CAAC,QAAQ,CAAC,EAAE,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,EACtC,GAAG,CAAC,YAAY,CAAC,EAAE,CAAC,CAAC,EAAE,GAAG,OAAO,EAAE,YAAY,EAAE,CAAC,CAAC,EACnD,UAAU,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,OAAO,EAAE,KAAK,EAAE,YAAY,EAAE,IAAI,EAAE,CAAC,CAAC,CACnE,CAAC;IACJ,CAAC;IAEO,cAAc,CAAC,EAAE,IAAI,EAAO,EAAE,cAA+B,EAAE,SAAsC;QAC3G,OAAO,IAAI,KAAK,cAAc,CAAC,GAAG,CAAC,IAAI,CAAC,kCAAkC;YACxE,CAAC,CAAC,EAAE,CAAC,cAAc,CAAC;YACpB,CAAC,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;IAC9B,CAAC;IAED,oFAAoF;IACpF,4EAA4E;IAC5E,WAAW,CAAC,SAAsC,EAAE,OAAgB,EAAE,cAA+B;QACnG,OAAO,GAAG,CACR,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,GAAG,EAAE,cAAc,EAAE,SAAS,CAAC,EAC3D,IAAI,CAAC,MAAM,CAAC,WAAW,CACxB,CAAC,IAAI,CACJ,GAAG,CAAC,CAAC,CAAC,QAAQ,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,GAAG,QAAQ,EAAE,GAAG,OAAO,EAAE,CAAoB,CAAC,CACtE,CAAC;IACJ,CAAC;CACF;AAAA,CAAC","sourcesContent":["import { of, zip, Observable } from \"rxjs\";\nimport { catchError, map, take, switchMap } from \"rxjs/operators\";\n\nimport { fetchRx, Context } from \"./common\";\nimport { HyPushState } from './index';\n\nexport interface ResponseContext extends Context {\n  responseText: string | null;\n  error?: any;\n};\n\nexport interface ResponseContextOk extends ResponseContext {\n  responseText: string;\n};\n\nexport interface ResponseContextErr extends ResponseContext {\n  responseText: null;\n  error: any;\n};\n\nexport class FetchManager {\n  private parent: HyPushState;\n\n  constructor(parent: HyPushState) {\n    this.parent = parent;\n  }\n\n  fetchPage(context: Context): Observable<ResponseContext> {\n    return fetchRx(context.url.href, {\n      method: \"GET\",\n      mode: 'cors', ///isExternal(this.parent) ? 'cors' : undefined,\n      headers: { Accept: \"text/html\" },\n    })\n    .pipe(\n      switchMap(response => response.text()),\n      map(responseText => ({ ...context, responseText })),\n      catchError(error => of({ ...context, error, responseText: null })),\n    );\n  }\n\n  private selectPrefetch({ href }: URL, latestPrefetch: ResponseContext, prefetch$: Observable<ResponseContext>) {\n    return href === latestPrefetch.url.href // && latestPrefetch.error == null\n      ? of(latestPrefetch)\n      : prefetch$.pipe(take(1));\n  }\n\n  // Returns an observable that emits exactly one notice, which contains the response.\n  // It will not emit until an (optional) page transition animation completes.\n  getResponse(prefetch$: Observable<ResponseContext>, context: Context, latestPrefetch: ResponseContext) {\n    return zip(\n      this.selectPrefetch(context.url, latestPrefetch, prefetch$),\n      this.parent.animPromise,\n    ).pipe(\n      map(([prefetch]) => ({ ...prefetch, ...context }) as ResponseContext),\n    );\n  }\n};\n"]}